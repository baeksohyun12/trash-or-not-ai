>**이름**: 강영빈<br>
>**담당파트**: 지도 및 위치 서비스, 인프라 및 배포, 예외 처리 UI, api 연동, 하이스코어 화면, 분리수거 모달창
>**작성 일자**: 2025.12.20 
---
# 리스크 관리 문서
## 1. 위치 기반 서비스 - GPS 좌표 튐 및 정확도 문제
* **발생 문제**:
    * 실내 환경에서 navigator.geolocation 호출 시 초기 GPS 신호 불안정으로 인한 위치 오차 발생가 발생함
* **해결 및 대응 :**
   * **다중 샘플링 및 최적값 알고리즘 적용**
        * 대응 1: 위치 측정을 1회로 끝내지 않고 setTimeout을 활용해 반복 측정 시도함
        * 대응 2: 수집된 positions 중 accuracy 수치가 가장 낮은 값을 reduce 함수로 선별하여 최종 좌표로 채택함

<details>
<summary>코드 보기</summary>

```javascript
function getUserLocation() {
    if (navigator.geolocation) {
        let positions = [];
        let attempts = 0;
        const maxAttempts = 3;
        
        const getPosition = () => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    positions.push({
                        lat: position.coords.latitude,
                        lng: position.coords.longitude,
                        accuracy: position.coords.accuracy
                    });
                    
                    attempts++;
                    
                    console.log(`📍 위치 측정 ${attempts}/${maxAttempts}:`, {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude,
                        accuracy: Math.round(position.coords.accuracy) + 'm'
                    });
                    
                    // 여러 번 측정해서 평균 내기 (건물 안에서 정확도 향상)
                    if (attempts < maxAttempts) {
                        setTimeout(getPosition, 1000); // 1초 후 다시 측정
                    } else {
                        // 가장 정확한 위치 선택 (accuracy가 낮을수록 정확함)
                        const bestPosition = positions.reduce((best, current) => 
                            current.accuracy < best.accuracy ? current : best
                        );
                    }
                }
            );
            }
        };
    }
```
</details>

## 2. 외부 API  로드 시점 불일치
* **발생 문제**:
    * 네트워크 지연 시 DOM은 렌더링 되었으나 Kakao Map SDK가 로드되지 않아 kakao is not defined 에러 발생함
* **해결 및 대응 :**
   * **Retry 패턴 구현**
        * 대응 1: typeof kakao 체크를 통해 로드 여부를 확인함
        * 대응 2: 로드되지 않았을 경우 setTimeout을 사용하여 1초 후 재귀 호출loadKakaoMap 하도록 방어 코드 구현 완료(최대 5회)
    
<details>
<summary>코드 보기</summary>

```javascript
function loadKakaoMap() {
    // Kakao API 로드 확인
    if (typeof kakao === 'undefined' || !kakao.maps) {
        kakaoLoadRetryCount++;
        
        if (kakaoLoadRetryCount > 5) {
            console.error('❌ Kakao Map API 로드 실패 (5회 재시도 초과)');
            console.error('💡 Kakao Developers에서 도메인 설정을 확인해주세요:');
            console.error('   플랫폼 > Web > 사이트 도메인');
            showMapError();
            return;
        }
        
        console.warn(`⏳ Kakao Map API 로딩 대기 중... (${kakaoLoadRetryCount}/5)`);
        setTimeout(loadKakaoMap, 1000);
        return;
    }
}
```
</details>

## 3. 대용량 데이터셋 처리 성능 저하
* **발생 문제**:
    * 제주도 전역 클린하우스 CSV 데이터를 매번 요청/파싱 시 네트워크 트래픽 및 렌더링 지연 발생함
* **해결 및 대응 :**
   * **클라이언트 사이드 캐싱 전략**
        * 대응 1: CACHE_TTL 상수를 5분(300,000ms)으로 정의함
        * 대응 2: 현재 시간과 마지막 요청 시간cachedTimestamp을 비교하여, 유효 기간 내에는 네트워크 요청 없이 메모리에 저장된 cachedResults를 즉시 반환함

<details>
<summary>코드 보기</summary>

```javascript
// CSV 경로 및 캐시 설정
const CSV_URL = 'data/jeju_cleanhouse.csv';
let cachedResults = null;
let cachedTimestamp = 0;
const CACHE_TTL = 5 * 60 * 1000; // 5분

// 모든 클린하우스 동일한 운영 시간
const DEFAULT_OPERATING_HOURS = '15:00 - 04:00';

/**
 * 주변 클린하우스 정보 가져오기 (카카오맵 장소 검색 사용)
 * @param {number} lat - 위도
 * @param {number} lng - 경도
 * @param {number} radius - 반경 (미터, 기본 5000m)
 * @returns {Promise<Array>} 클린하우스 목록
 */
export async function getNearbyCleanHouses(lat, lng, radius = 5000) {
    // 캐시가 유효하면 캐시 사용
    const now = Date.now();
    if (cachedResults && (now - cachedTimestamp) < CACHE_TTL) {
        console.log('🗂️ 캐시된 클린하우스 결과 사용');
        return takeNearest(cachedResults, lat, lng, radius);
    }
```
</details>

## 4. 백엔드 통신 실패 및 예외 처리
* **발생 문제**:
    * AI 분석 서버 응답 지연 또는 실패 시 서비스 중단 현상 우려
* **해결 및 대응 :**
   * **Mock Data Fallback**
        * 대응 1: analyzeImage 함수 호출 실패 시, 에러를 로깅하고 mockAiAnalysis 함수를 호출하여 앱이 멈추지 않고 결과 화면으로 정상 진입하도록 예외 처리함

<details>
<summary>코드 보기</summary>

```javascript
const minLoadingTime = new Promise(resolve => setTimeout(resolve, 2500));
        
        // 실제 데이터 요청 (실패 시 mock 데이터 사용하도록 예외처리 포함)
        const analysisRequest = analyzeImage(currentImageFile)
            .catch(error => {
                console.error('❌ 분석 중 오류(서버):', error);
                return mockAiAnalysis(currentImageSrc);
            });
```
</details>

## 5. 게임 데이터 휘발성 문제 
* **발생 문제**:
    * 게임 '다시 하기' 버튼 클릭 시, 점수 저장 로직보다 초기화 로직이 먼저 실행되어 최고 기록 유실이 됨
* **해결 및 대응 :**
   * **로직 순서 재설계 및 영구 저장**
        * 대응 1: restartGame 함수 도입부에서 현재 점수와 최고 점수getHighScore를 비교함
        * 대응 2: 신기록일 경우 setHighScore를 통해 localStorage에 즉시 저장함
        * 대응 3: 데이터 저장 후 게임 초기화stopGame가 실행되도록 순서 보장함

<details>
<summary>코드 보기</summary>

```javascript
function restartGame() {
    // 현재 점수를 먼저 저장
    const scoreEl = document.getElementById('game-score');
    if (scoreEl) {
        const currentScore = parseInt(scoreEl.innerText.replace(/,/g, '')) || 0;
        const highScore = getHighScore();
        
        console.log('📊 다시하기 클릭 - 현재:', currentScore, '/ 최고:', highScore);
        
        // 하이스코어 갱신
        if (currentScore > highScore) {
            setHighScore(currentScore);
            console.log('🎉 하이스코어 갱신!', currentScore);
        }
        
        // BEST 점수 화면 업데이트
        const bestScoreEl = document.getElementById('game-best-score');
        if (bestScoreEl) {
            const newBest = getHighScore().toLocaleString();
            bestScoreEl.innerText = newBest;
            console.log('✅ BEST 화면 업데이트:', newBest);
        } else {
            console.warn('⚠️ game-best-score 요소를 찾을 수 없음');
        }
    } else {
        console.warn('⚠️ game-score 요소를 찾을 수 없음');
    }
    
    stopGame();
    startNewGameLogic();
}
```
</details>

## 6. AI 분석 대기 시간의 심리적 UX
* **발생 문제**:
    * 너무 빠른 분석 결과 반환은 사용자에게 "제대로 분석되지 않았다"는 심리적 불신감 유발 및 로딩 화면 깜빡임 발생함
* **해결 및 대응 :**
   * **최소 로딩 시간 보장**
        * 대응 1: setTimeout을 이용해 2.5초의 지연을 주는 Promise 객체minLoadingTime 생성함
        * 대응 2: Promise.all([minLoadingTime, analysisRequest])를 사용하여, 분석이 일찍 끝나더라도 최소 2.5초간 3D 지구본 애니메이션을 보여준 후 결과 화면으로 전환함

<details>
<summary>코드 보기</summary>

```javascript
 // 2. 로딩 화면 시작 (프로그래스바 애니메이션이 약 2.5초)
    renderLoadingState();
    
    try {
        
        const minLoadingTime = new Promise(resolve => setTimeout(resolve, 2500));
        
        // 실제 데이터 요청 (실패 시 mock 데이터 사용하도록 예외처리 포함)
        const analysisRequest = analyzeImage(currentImageFile)
            .catch(error => {
                console.error('❌ 분석 중 오류(서버):', error);
                return mockAiAnalysis(currentImageSrc);
            });

        // Promise.all-> "시간도 2.5초 지났고, 분석도 끝났을 때" 결과를 반환
        const [_, result] = await Promise.all([minLoadingTime, analysisRequest]);
    }
```
</details>